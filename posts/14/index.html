<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="面试期间常被问到的一些问题">
<meta property="og:type" content="blog">
<meta property="og:title" content="前端面试题-JavaScript">
<meta property="og:url" content="http://example.com/posts/14/index.html">
<meta property="og:site_name" content="李正浩的个人博客">
<meta property="og:description" content="面试期间常被问到的一些问题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-27T01:04:40.000Z">
<meta property="article:modified_time" content="2023-07-03T09:23:56.920Z">
<meta property="article:author" content="壮壮姐姐~">
<meta property="article:tag" content="高频前端面试题">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/posts/14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/posts/14/","path":"posts/14/","title":"前端面试题-JavaScript"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端面试题-JavaScript | 李正浩的个人博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?bfa9046a9727afd7b1ddf08f308c3468"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">李正浩的个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">壮壮姐姐~</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="李正浩的个人博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">js 有哪些内置对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">什么是闭包？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">如何理解作用域、作用域链和执行上下文？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">如何创建一个没有原型的对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">如何理解原型链？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let-const-var-%E6%AF%94%E8%BE%83"><span class="nav-number">6.</span> <span class="nav-text">let const var 比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-stringify-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">JSON.stringify 有什么缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">for…in 和 for…of 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-V8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">谈谈你对 V8 垃圾回收的理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">10.</span> <span class="nav-text">new 操作符都做了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cdom-%E7%9A%84%E7%B1%BB%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E7%BB%84"><span class="nav-number">11.</span> <span class="nav-text">类数组和数组的区别，dom 的类数组如何转换成数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offsetWidth-x2F-offsetHeight%EF%BC%8CclientWidth-x2F-clientHeight-%E4%B8%8E-scrollWidth-x2F-scrollHeight-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mouseover-x2F-mouseout-%E4%B8%8E-mouseenter-x2F-mouseleave-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">13.</span> <span class="nav-text">mouseover&#x2F;mouseout 与 mouseenter&#x2F;mouseleave 的区别与联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#event-stopPropagation-%E4%B8%8E-event-stopImmediatePropagation-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">event.stopPropagation()与 event.stopImmediatePropagation 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-Event-Loop"><span class="nav-number">15.</span> <span class="nav-text">说一下事件循环机制 Event Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#esm-%E5%92%8C-commonjs-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">esm 和 commonjs 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B-JavaScript-%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">解释下 JavaScript 栈内存和堆内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">箭头函数与普通函数区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isNaN-%E4%B8%8E-Number-isNaN-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">isNaN 与 Number.isNaN 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-this-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">20.</span> <span class="nav-text">谈谈你对 this 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">21.</span> <span class="nav-text">谈谈你对严格模式的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Promise-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">22.</span> <span class="nav-text">谈谈你对 Promise 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-%E4%B8%8D%E7%AD%89%E4%BA%8E-0-3"><span class="nav-number">23.</span> <span class="nav-text">为什么 0.1+0.2 不等于 0.3</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="壮壮姐姐~"
      src="/images/head_2.gif">
  <p class="site-author-name" itemprop="name">壮壮姐姐~</p>
  <div class="site-description" itemprop="description">心有所向，无问东西</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/060421" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;060421" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
            
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head_2.gif">
      <meta itemprop="name" content="壮壮姐姐~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李正浩的个人博客">
      <meta itemprop="description" content="心有所向，无问东西">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="前端面试题-JavaScript | 李正浩的个人博客">
      <meta itemprop="description" content="面试期间常被问到的一些问题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端面试题-JavaScript
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-27 09:04:40" itemprop="dateCreated datePublished" datetime="2022-04-27T09:04:40+08:00">2022-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-03 17:23:56" itemprop="dateModified" datetime="2023-07-03T17:23:56+08:00">2023-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E9%82%A3%E7%82%B9%E4%BA%8B/" itemprop="url" rel="index"><span itemprop="name">面试那点事</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.6k</span>
    </span>
</div>

            <div class="post-description">面试期间常被问到的一些问题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="js-有哪些内置对象？"><a href="#js-有哪些内置对象？" class="headerlink" title="js 有哪些内置对象？"></a>js 有哪些内置对象？</h3><p>JavaScript 有许多内置对象，包括但不限于：</p>
<ul>
<li>基本对象： Object、Boolean、Symbol、Number、String</li>
<li>符合数据结构：Array、Set、Map、WeakSet、WeakMap</li>
<li>日期和时间对象：Date</li>
<li>数学计算对象：Math</li>
<li>正则表达式对象：RegExp</li>
<li>函数对象：Function</li>
<li>错误对象：Error、TypeError、RangeError 等</li>
<li>其他对象：Global、JSON 等</li>
</ul>
<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>闭包是指一个函数可以访问另一个函数作用域内的变量。当一个函数嵌套在另一个函数中时，内部函数可以访问外部函数的变量，即使外部函数已经返回了。这种情况下，内部函数形成了一个闭包，它保留了外部函数的作用域链并可以继续访问这些变量。闭包常常用于实现函数的封装和私有化，以及在回调和事件处理等场景下的数据共享与传递。</p>
<h3 id="如何理解作用域、作用域链和执行上下文？"><a href="#如何理解作用域、作用域链和执行上下文？" class="headerlink" title="如何理解作用域、作用域链和执行上下文？"></a>如何理解作用域、作用域链和执行上下文？</h3><p>在 JavaScript 中，作用域、作用域链和执行上下文是密切相关的概念，它们与变量和函数的查找、访问以及生命周期有关。</p>
<ol>
<li><p>作用域（Scope）：</p>
<p><strong>作用域是一个变量或函数的可访问范围</strong>。JavaScript 中有三种作用域：<strong>全局作用域</strong>、<strong>局部（函数）作用域</strong>和<strong>块级作用域</strong>。全局作用域中声明的变量和函数可以在整个代码中访问，局部作用域中声明的变量和函数只能在特定的函数内部访问，块级作用域在一对花括号内定义，对<code>let</code>和<code>const</code>关键字声明的变量有效。</p>
<p>变量的生命周期受其作用域的限制。全局作用域中的变量在整个程序执行过程中持续存在，局部作用域中的变量在函数执行结束时销毁，块级作用域在代码块执行结束时，块级作用域中的变量将被销毁。</p>
</li>
<li><p>作用域链（Scope Chain）：</p>
<p><strong>当代码执行过程中访问一个变量或函数时，JavaScript 引擎会沿着作用域链查找该标识符</strong>。作用域链是由当前执行上下文的作用域和其所有父级作用域组成的链表。</p>
<p>查找过程从当前作用域开始，然后逐级向上查找，直到找到目标标识符或到达全局作用域。如果在全局作用域中仍未找到目标标识符，则返回<code>undefined</code>。</p>
</li>
<li><p>执行上下文（Execution Context）：</p>
<p><strong>执行上下文是 JavaScript 代码执行过程中的环境</strong>。每当进入一个新的函数执行或全局代码执行时，都会创建一个新的执行上下文。执行上下文包含了当前执行的代码所需的所有信息，如变量、函数、作用域链等。</p>
<p>JavaScript 引擎使用执行上下文栈（Execution Context Stack）来管理执行上下文。栈顶的执行上下文为当前执行的代码环境。当一个函数被调用时，一个新的执行上下文被压入栈顶；当函数执行结束时，执行上下文从栈顶弹出，返回到调用者的上下文环境。</p>
</li>
</ol>
<p>总结起来，作用域是变量和函数的可访问范围；作用域链是由当前执行上下文的作用域和其父级作用域组成的链表，用于在代码执行过程中查找变量和函数；执行上下文是代码执行过程中的环境，包含了当前执行的代码所需的所有信息。这三者共同决定了代码执行过程中变量和函数的查找、访问以及生命周期。</p>
<h3 id="如何创建一个没有原型的对象？"><a href="#如何创建一个没有原型的对象？" class="headerlink" title="如何创建一个没有原型的对象？"></a>如何创建一个没有原型的对象？</h3><p>可以使用 Object.create(null) 方法创建一个没有原型的对象。这个方法创建一个全新的对象并将其原型设置为 null，因此它没有继承任何属性或方法。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">toString</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="如何理解原型链？"><a href="#如何理解原型链？" class="headerlink" title="如何理解原型链？"></a>如何理解原型链？</h3><p>原型链是 JavaScript 中实现继承的一种机制，它通过让一个对象的原型指向另一个对象，从而使得一个对象可以访问另一个对象中定义的属性和方法。当我们试图访问一个对象中不存在的属性或方法时，JavaScript 引擎会沿着原型链一直向上查找，直到找到该属性或方法为止，或者最终抵达 Object.prototype（所有对象的祖先）上停止查找。</p>
<h3 id="let-const-var-比较"><a href="#let-const-var-比较" class="headerlink" title="let const var 比较"></a>let const var 比较</h3><ol>
<li>作用域：<ul>
<li><code>var</code>：声明的变量具有函数作用域。这意味着在函数内部声明的变量只能在该函数内部访问，而在函数外部声明的变量具有全局作用域。</li>
<li><code>let</code>和<code>const</code>：声明的变量具有块级作用域。这意味着变量仅在声明它们的代码块（例如：<code>if</code>语句、<code>for</code>循环、<code>while</code>循环等）内部可访问。</li>
</ul>
</li>
<li>变量提升（Hoisting）：<ul>
<li><code>var</code>：声明的变量会被提升到所在作用域的顶部。这意味着在声明之前访问变量不会导致引用错误，但变量的值将是<code>undefined</code>。</li>
<li><code>let</code>和<code>const</code>：声明的变量不会被提升。在声明之前访问变量会导致引用错误。</li>
</ul>
</li>
<li>重复声明：<ul>
<li><code>var</code>：允许在同一作用域内多次声明同名变量，后续声明将被忽略。</li>
<li><code>let</code>和<code>const</code>：在同一作用域内不允许重复声明同名变量。尝试这样做会导致语法错误。</li>
</ul>
</li>
<li>变量的可变性：<ul>
<li><code>var</code>和<code>let</code>：声明的变量可被重新赋值。</li>
<li><code>const</code>：声明的变量是不可变的，即一旦赋值，无法更改。这对于声明常量或确保某个变量在整个程序执行过程中保持不变的情况非常有用。</li>
</ul>
</li>
</ol>
<h3 id="JSON-stringify-有什么缺点？"><a href="#JSON-stringify-有什么缺点？" class="headerlink" title="JSON.stringify 有什么缺点？"></a>JSON.stringify 有什么缺点？</h3><p><code>JSON.stringify()</code>是一个将 JavaScript 对象转换为 JSON 字符串的方法。尽管它在许多情况下非常有用，但它确实存在一些限制和缺点：</p>
<ol>
<li>循环引用：<code>JSON.stringify()</code>无法处理具有循环引用的对象。如果一个对象的属性直接或间接引用了自身，<code>JSON.stringify()</code>将抛出一个错误，表示存在循环引用。</li>
<li><code>undefined</code>、函数和 Symbol 忽略：<code>JSON.stringify()</code>不会序列化对象中的<code>undefined</code>、函数和 Symbol 类型的属性。这些属性将被忽略，不会出现在生成的 JSON 字符串中，单独转换则会返回<code>undefined</code>。</li>
<li>丢失原型链：在对象序列化后，原型链上的属性和方法将丢失。只有对象自身的可枚举属性会被序列化。因此，在反序列化（使用<code>JSON.parse()</code>）后，原始对象的原型链信息将不复存在。</li>
<li>日期对象处理：当使用<code>JSON.stringify()</code>序列化日期对象时，日期对象会被转换为它们的 ISO 字符串表示形式。在反序列化时，这些日期将被视为普通字符串，而不是日期对象。</li>
<li>非数组和非对象的值：对于不是数组或对象的顶层值（例如：字符串、数字、布尔值等），<code>JSON.stringify()</code>会直接返回其对应的 JSON 表示，而不会将其包装在对象或数组中。</li>
</ol>
<h3 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别?"></a>for…in 和 for…of 的区别?</h3><p>for…in 循环用于遍历对象的可枚举属性，返回的是属性名称；for…of 循环用于遍历可迭代对象（如数组、字符串、Map、Set 等），返回的是元素值。</p>
<h3 id="谈谈你对-V8-垃圾回收的理解？"><a href="#谈谈你对-V8-垃圾回收的理解？" class="headerlink" title="谈谈你对 V8 垃圾回收的理解？"></a>谈谈你对 V8 垃圾回收的理解？</h3><p>V8 引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。</p>
<ol>
<li>分代收集：V8 将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用 Scavenge 算法进行垃圾回收，通常采用 Cheney 算法，将内存分为两个半区（From Space 和 To Space），每次垃圾回收时，会将存活的对象复制到 To Space 中，并清空 From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。</li>
<li>增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8 采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript 程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。</li>
</ol>
<p>V8 垃圾回收是对 JavaScript 垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。</p>
<h3 id="new-操作符都做了什么"><a href="#new-操作符都做了什么" class="headerlink" title="new 操作符都做了什么"></a>new 操作符都做了什么</h3><ol>
<li>创建一个新对象</li>
<li>对象的<code>__proto__</code>指向构造函数的<code>prototype</code></li>
<li>构造函数将对象绑定到<code>this</code>并调用</li>
<li>如果构造函数返回对象或函数则直接返回，否则返回这个新对象</li>
</ol>
<h3 id="类数组和数组的区别，dom-的类数组如何转换成数组"><a href="#类数组和数组的区别，dom-的类数组如何转换成数组" class="headerlink" title="类数组和数组的区别，dom 的类数组如何转换成数组"></a>类数组和数组的区别，dom 的类数组如何转换成数组</h3><p>类数组（Array-like）和数组（Array）都是用于存储多个值的数据结构，但它们之间存在一些关键区别：</p>
<ol>
<li>类型：数组是 JavaScript 的内置对象类型，继承自<code>Array.prototype</code>，具有一系列数组方法（如<code>push()</code>、<code>pop()</code>、<code>map()</code>等）。类数组是普通的对象，其属性名为索引（如<code>0</code>、<code>1</code>、<code>2</code>等），具有一个<code>length</code>属性，但不具备数组的方法。</li>
<li>原型：数组的原型为<code>Array.prototype</code>，因此具有数组的所有方法。类数组的原型通常为<code>Object.prototype</code>，并不包含数组的方法。</li>
</ol>
<p>要将 DOM 的类数组（例如，通过<code>document.getElementsByClassName()</code>或<code>document.querySelectorAll()</code>获取的元素集合）转换为数组，可以使用以下方法之一：</p>
<ol>
<li><p>使用<code>Array.from()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(nodeList);</span><br></pre></td></tr></table></figure>

<p><code>Array.from()</code>方法会创建一个新数组，并将类数组的元素逐个复制到新数组中。</p>
</li>
<li><p>使用扩展运算符（Spread Operator）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>

<p>扩展运算符<code>...</code>可以将类数组直接转换为数组。</p>
</li>
<li><p>使用<code>Array.prototype.slice.call()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> array = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(nodeList);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>Array.prototype.slice.call()</code>方法会将类数组作为上下文，并创建一个新数组，将类数组的元素逐个复制到新数组中。</p>
<p>这些方法可以将类数组转换为数组，这样就可以在转换后的数组上使用数组的方法了。注意，这些方法不仅适用于 DOM 类数组，还适用于其他类数组对象。</p>
<h3 id="offsetWidth-x2F-offsetHeight，clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别"><a href="#offsetWidth-x2F-offsetHeight，clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别" class="headerlink" title="offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别"></a>offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别</h3><p>offsetWidth&#x2F;offsetHeight 是元素的可见宽度&#x2F;高度加上 padding、border 和滚动条（如果存在）的宽度&#x2F;高度。</p>
<p>clientWidth&#x2F;clientHeight 是元素的可见宽度&#x2F;高度，不包括 padding 和滚动条。</p>
<p>scrollWidth&#x2F;scrollHeight 是元素内容的完整宽度&#x2F;高度，包括溢出部分。如果元素没有溢出，则 scrollWidth&#x2F;scrollHeight 等于 clientWidth&#x2F;clientHeight。如果有溢出，则 scrollWidth&#x2F;scrollHeight 大于 clientWidth&#x2F;clientHeight。</p>
<h3 id="mouseover-x2F-mouseout-与-mouseenter-x2F-mouseleave-的区别与联系"><a href="#mouseover-x2F-mouseout-与-mouseenter-x2F-mouseleave-的区别与联系" class="headerlink" title="mouseover&#x2F;mouseout 与 mouseenter&#x2F;mouseleave 的区别与联系"></a>mouseover&#x2F;mouseout 与 mouseenter&#x2F;mouseleave 的区别与联系</h3><p>mouseover 和 mouseout 是 HTML DOM 事件，它们会在鼠标移入或移出元素时触发。它们也会在鼠标指针进入或离开<strong>子元素</strong>时触发。这也就是说，如果在父元素上有 mouseover 事件，并且鼠标指针进入子元素，则该元素上仍然会触发 mouseover 事件。mouseout 同理。</p>
<p>mouseenter 和 mouseleave 事件也是在鼠标进入或离开元素时触发。与 mouseover 和 mouseout 不同的是，mouseenter 和 mouseleave 事件<strong>不会传播到子元素</strong>。因此，如果鼠标指针进入或离开元素的子元素，则不会触发 mouseenter 和 mouseleave 事件。</p>
<h3 id="event-stopPropagation-与-event-stopImmediatePropagation-的区别"><a href="#event-stopPropagation-与-event-stopImmediatePropagation-的区别" class="headerlink" title="event.stopPropagation()与 event.stopImmediatePropagation 的区别"></a>event.stopPropagation()与 event.stopImmediatePropagation 的区别</h3><p>event.stopPropagation()可以阻止事件冒泡到父元素，但不阻止其他事件处理程序的执行。而 event.stopImmediatePropagation()可以立即阻止事件冒泡并取消同一元素上其他事件处理程序的执行。</p>
<h3 id="说一下事件循环机制-Event-Loop"><a href="#说一下事件循环机制-Event-Loop" class="headerlink" title="说一下事件循环机制 Event Loop"></a>说一下事件循环机制 Event Loop</h3><p>事件循环（Event Loop）是 JavaScript 运行时环境中的一个核心概念，它负责协调异步操作和同步代码的执行。JavaScript 是单线程的，这意味着它一次只能执行一个任务。事件循环使 JavaScript 能够在执行同步代码的同时，处理异步操作（如定时器、用户交互和网络请求）的回调。</p>
<p>事件循环的工作原理大致如下：</p>
<ol>
<li>首先，JavaScript 引擎执行全局同步代码（例如来自<code>&lt;script&gt;</code>标签或 Node.js 文件的代码）。</li>
<li>当遇到异步操作（如 <code>setTimeout</code>、<code>setInterval</code>、<code>Promise</code>、<code>fetch</code> 等），它们的回调函数会被放入相应的任务队列中（微任务队列或宏任务队列）。</li>
<li>同步代码执行完成后，事件循环开始检查微任务队列。如果队列中有任务，事件循环将依次执行它们，直到队列为空。</li>
<li>接下来，事件循环检查宏任务队列。如果队列中有任务，事件循环将执行第一个任务，然后返回到微任务队列，检查是否有新的微任务需要执行。</li>
<li>事件循环在微任务队列和宏任务队列之间循环，依次执行队列中的任务。当两个队列都为空时，事件循环将等待新的任务（如用户交互或网络请求回调）。</li>
<li>当新任务出现时，事件循环将其添加到相应的队列中，并继续循环执行任务。</li>
</ol>
<p>事件循环的目标是在处理同步代码和异步回调之间保持平衡，确保 JavaScript 代码的执行效率和响应能力。通过这种方式，事件循环允许 JavaScript 在单线程环境中有效地处理并发操作。</p>
<h3 id="esm-和-commonjs-的区别"><a href="#esm-和-commonjs-的区别" class="headerlink" title="esm 和 commonjs 的区别"></a>esm 和 commonjs 的区别</h3><p>ESM（ECMAScript Modules）和 CommonJS 是 JavaScript 中两种不同的模块系统。它们都允许将代码拆分成可重用的模块，并在需要时导入这些模块。尽管它们都实现了相似的功能，但它们之间存在一些关键差异：</p>
<ol>
<li><p>语法：ESM 和 CommonJS 使用不同的语法来导入和导出模块。</p>
<ul>
<li>ESM 使用 <code>import</code> 和 <code>export</code> 关键字</li>
<li>CommonJS 使用 <code>require</code> 和 <code>module.exports</code>关键字</li>
</ul>
</li>
<li><p>运行时加载与静态加载：</p>
<ul>
<li>CommonJS 是<strong>运行时加载</strong>，这意味着模块在运行时解析和加载。因此，在运行时可以动态修改模块和依赖关系。</li>
<li>ESM 是<strong>静态加载</strong>，这意味着模块在编译时解析和加载。这允许更好的优化，如代码消除和更快的加载速度，但不允许在运行时动态修改模块。</li>
</ul>
</li>
<li><p>作用域：ESM 和 CommonJS 在处理变量作用域方面有所不同。</p>
<ul>
<li>ESM 使用<strong>模块作用域</strong>，每个模块具有自己的顶级作用域。在模块内声明的变量不会污染全局作用域。</li>
<li>CommonJS 使用<strong>文件作用域</strong>，但与 ESM 不同，CommonJS 模块可以通过 <code>global</code> 对象访问全局作用域。</li>
</ul>
</li>
<li><p>循环依赖：ESM 和 CommonJS 处理循环依赖的方式不同。</p>
<ul>
<li>ESM 可以更好地处理循环依赖，因为模块是静态加载的。在循环依赖中，导入的值可能是不完整的，但不会导致错误。</li>
<li>CommonJS 在处理循环依赖时可能会遇到问题，因为模块是运行时加载的。这可能导致在循环依赖中的模块中获得一个不完整的对象。</li>
</ul>
</li>
<li><p>兼容性和使用场景：</p>
<ul>
<li>CommonJS 主要用于 Node.js 环境，因为它是 Node.js 的原生模块系统。虽然现代 Node.js 版本也支持 ESM，但很多旧的 Node.js 代码仍使用 CommonJS。然而，许多新的 Node.js 项目逐渐采用 ESM。</li>
<li>ESM 通常用于现代 Web 开发，因为大多数现代浏览器原生支持 ESM。在使用构建工具（如 Webpack、Rollup 或 Parcel）时，ESM 也提供了更好的优化和打包能力。</li>
</ul>
</li>
<li><p>实时绑定与值拷贝：</p>
<ul>
<li>ESM 使用<strong>实时绑定</strong>，当导入的值发生更改时，导入模块的值也会跟着更改。这意味着导入的值始终保持最新。</li>
<li>CommonJS 使用<strong>值拷贝</strong>，当模块被导入时，值被复制到导入模块。这意味着在导入模块中，值的更改不会反映到原始模块，导入的值在导入时是固定的。</li>
</ul>
</li>
<li><p>导出值：</p>
<ul>
<li>ESM 导出值是<strong>映射关系</strong>，<strong>可读，不可修改</strong>，但可通过导出的函数修改导出的值。</li>
<li>CoomonJS 导出<strong>值的拷贝</strong>，<strong>可以修改导出的值</strong>。</li>
</ul>
</li>
<li><p>export 使用：</p>
<ul>
<li>ESM export 和 export default 支持一起使用。</li>
<li>CoomonJS module.exports 和 exports 不支持一起使用，会被覆盖。</li>
</ul>
</li>
</ol>
<p>总结一下，ESM 和 CommonJS 的主要区别在于它们的语法、加载机制、作用域、循环依赖处理、兼容性和使用场景以及实时绑定与值拷贝。尽管它们在某些方面有所不同，它们都是为了解决 JavaScript 模块化编程的问题。</p>
<h3 id="解释下-JavaScript-栈内存和堆内存？"><a href="#解释下-JavaScript-栈内存和堆内存？" class="headerlink" title="解释下 JavaScript 栈内存和堆内存？"></a>解释下 JavaScript 栈内存和堆内存？</h3><p>在 JavaScript 中，栈内存（Stack Memory）和堆内存（Heap Memory）扮演着不同的角色，它们分别负责存储不同类型的数据。以下是它们在 JavaScript 中的简要说明：</p>
<ol>
<li>栈内存（Stack Memory）：<ul>
<li>栈内存主要用于存储基本类型（原始类型）的值，如 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code> 和 <code>undefined</code>。这些类型的值通常较小且固定大小。</li>
<li>栈内存还负责存储函数调用的执行上下文、局部变量和临时数据。</li>
<li>栈内存遵循后进先出（LIFO）的原则进行分配和释放空间。当函数被调用时，函数的执行上下文、局部变量和相关信息会被压入栈中；当函数返回时，这些数据会从栈中弹出。</li>
<li>栈内存的分配和回收速度较快，因为内存管理由 JavaScript 引擎自动完成。</li>
<li>由于栈内存有限，如果递归调用过深或者分配大量的局部变量，可能导致栈溢出。</li>
</ul>
</li>
<li>堆内存（Heap Memory）：<ul>
<li>堆内存主要用于存储引用类型的值，如对象（<code>object</code>）、数组（<code>array</code>）和函数（<code>function</code>）。这些类型的值通常较大，大小不固定。</li>
<li>JavaScript 引擎使用垃圾回收机制自动管理堆内存中的对象。当对象不再被引用时，它们会被标记为垃圾，并在下一次垃圾回收时释放内存。</li>
<li>与栈内存相比，堆内存分配和回收速度较慢，因为需要管理更复杂的数据结构和垃圾回收机制。</li>
<li>堆内存可以动态分配，因此可以存储更多数据。</li>
<li>如果没有正确处理引用关系，可能导致内存泄漏。</li>
</ul>
</li>
</ol>
<p>总结一下，在 JavaScript 中，栈内存用于存储基本类型的值、函数调用的执行上下文和局部变量，堆内存用于存储引用类型的值。理解栈内存和堆内存的差异有助于编写高效且内存友好的 JavaScript 程序。</p>
<h3 id="箭头函数与普通函数区别？"><a href="#箭头函数与普通函数区别？" class="headerlink" title="箭头函数与普通函数区别？"></a>箭头函数与普通函数区别？</h3><p>箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、<code>this</code> 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：</p>
<ol>
<li><code>this</code> 关键字绑定：<ul>
<li>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 <code>this</code>。</li>
<li>普通函数有自己的 <code>this</code>，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），<code>this</code> 的值可能会有所不同。</li>
</ul>
</li>
<li>arguments 对象：<ul>
<li>箭头函数没有自己的 <code>arguments</code> 对象。它们可以访问包围它们的普通函数的 <code>arguments</code> 对象。</li>
<li>普通函数有自己的 <code>arguments</code> 对象，这是一个类数组对象，包含了传递给函数的参数。</li>
</ul>
</li>
<li>构造函数行为：<ul>
<li>箭头函数不能作为构造函数使用，因此不能使用 <code>new</code> 关键字调用。它们也没有 <code>prototype</code> 属性。</li>
<li>普通函数可以作为构造函数使用，通过 <code>new</code> 关键字创建新的对象实例。</li>
</ul>
</li>
<li>原型链：<ul>
<li>由于箭头函数没有 <code>prototype</code> 属性，它们不能作为其他对象的原型。</li>
<li>普通函数有 <code>prototype</code> 属性，可以作为其他对象的原型。</li>
</ul>
</li>
<li>生成器：<ul>
<li>箭头函数不能使用<code>yield</code>关键字。</li>
<li>普通函数可以使用<code>yield</code>关键字变成生成器函数。</li>
</ul>
</li>
</ol>
<h3 id="isNaN-与-Number-isNaN-的区别"><a href="#isNaN-与-Number-isNaN-的区别" class="headerlink" title="isNaN 与 Number.isNaN 的区别"></a>isNaN 与 Number.isNaN 的区别</h3><p>isNaN 函数用于检查一个值是否是 NaN，它会将传入的参数先转换为数字类型再进行判断。如果传入的参数无法转换为数字类型，则会返回 true。</p>
<p>而 Number.isNaN 用于检查一个值是否为 NaN，但它不会将参数转换为数字类型，只有在参数本身就是 NaN 时才返回 true。否则，返回 false。</p>
<h3 id="谈谈你对-this-的理解"><a href="#谈谈你对-this-的理解" class="headerlink" title="谈谈你对 this 的理解"></a>谈谈你对 this 的理解</h3><p>在 JavaScript 中，<code>this</code> 是一个特殊的关键字，它在函数调用时动态地引用了一个对象。<code>this</code> 的值取决于函数的调用方式，不同的调用方式会导致 <code>this</code> 指向不同的对象。以下是一些关于 <code>this</code> 的不同用法和场景：</p>
<ol>
<li><p>全局上下文：</p>
<p>当在全局作用域中使用 <code>this</code> 时，它指向全局对象。在浏览器环境中，全局对象是 <code>window</code>；在 Node.js 环境中，全局对象是 <code>global</code>。</p>
</li>
<li><p>函数调用：</p>
<p>当在函数内部使用 <code>this</code> 且函数作为普通函数调用时（非对象方法调用），<code>this</code> 通常指向全局对象。但在严格模式下（使用 <code>&quot;use strict&quot;</code>），<code>this</code> 会被设置为 <code>undefined</code>。</p>
</li>
<li><p>对象方法调用：</p>
<p>当在对象的方法内部使用 <code>this</code> 时，<code>this</code> 指向调用该方法的对象。这也适用于原型链中的方法。</p>
</li>
<li><p>构造函数调用：</p>
<p>当在构造函数内部使用 <code>this</code> 且使用 <code>new</code> 关键字调用构造函数时，<code>this</code> 指向新创建的对象实例。</p>
</li>
<li><p>显式绑定：</p>
<p>使用 <code>call</code>、<code>apply</code> 或 <code>bind</code> 方法调用函数时，可以显式地将 <code>this</code> 绑定到一个指定的对象。</p>
</li>
<li><p>箭头函数：</p>
<p>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 <code>this</code>。</p>
</li>
</ol>
<p>总之，<code>this</code> 是 JavaScript 中一个动态上下文的关键字，它的值取决于函数调用的方式。</p>
<h3 id="谈谈你对严格模式的理解"><a href="#谈谈你对严格模式的理解" class="headerlink" title="谈谈你对严格模式的理解"></a>谈谈你对严格模式的理解</h3><p>在 JavaScript 中，严格模式（strict mode）和非严格模式（sloppy mode）主要有以下几个区别：</p>
<ol>
<li>变量声明： 在严格模式下，必须明确地声明变量（使用<code>let</code>、<code>const</code>或<code>var</code>关键字）。否则，将会抛出一个引用错误（ReferenceError）。在非严格模式下，如果没有声明变量，JavaScript 会自动将其声明为全局变量，这可能会导致意外的全局污染。</li>
<li>this 指针： 在严格模式下，全局作用域中的<code>this</code>值为<code>undefined</code>。在非严格模式下，全局作用域中的<code>this</code>值为全局对象（浏览器环境中为<code>window</code>对象，Node.js 环境中为<code>global</code>对象）。此外，在严格模式下，不允许使用<code>call</code>、<code>apply</code>或<code>bind</code>将<code>this</code>值设置为<code>null</code>或<code>undefined</code>。</li>
<li>禁止使用未来保留字： 严格模式中，不能将一些未来保留字（如<code>implements</code>、<code>interface</code>、<code>let</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>static</code>和<code>yield</code>）用作变量名或函数名。</li>
<li>禁止使用八进制字面量： 在严格模式下，不允许使用八进制字面量（如<code>0123</code>）。非严格模式下，八进制字面量是允许的。</li>
<li>禁止删除变量、函数和函数参数： 严格模式中，使用<code>delete</code>操作符删除变量、函数和函数参数会引发语法错误（SyntaxError）。在非严格模式下，这样的操作是允许的，但实际上不会删除这些对象。</li>
<li>限制函数参数的重复声明： 在严格模式下，如果一个函数具有多个相同名称的参数，将会抛出一个语法错误。非严格模式下允许这种重复声明，但只有最后一个参数值会生效。</li>
<li>错误处理： 严格模式相较于非严格模式，更严格地处理某些类型的错误。例如，当试图修改只读属性、给不可扩展的对象添加属性或删除不可配置的属性时，严格模式会抛出类型错误（TypeError），而非严格模式下则会静默失败。</li>
</ol>
<p>要启用严格模式，可以在脚本或函数开头添加<code>&quot;use strict&quot;;</code>指令。这将对整个脚本或函数体中的代码启用严格模式。推荐使用严格模式编写代码，因为它可以帮助发现潜在的错误并避免一些不良的编程实践。</p>
<h3 id="谈谈你对-Promise-的理解"><a href="#谈谈你对-Promise-的理解" class="headerlink" title="谈谈你对 Promise 的理解"></a>谈谈你对 Promise 的理解</h3><p>Promise 是一种在 JavaScript 中用于处理异步操作的编程模式。它表示一个尚未完成但预计在未来某个时刻完成的操作的结果。Promise 允许我们以更简洁、易读的方式处理异步操作，避免了传统的回调地狱（callback hell）问题。</p>
<p>Promise 有三种状态：</p>
<ol>
<li>pending（待定）：初始状态，既不是 fulfilled，也不是 rejected。</li>
<li>fulfilled（已实现）：表示异步操作已成功完成。</li>
<li>rejected（已拒绝）：表示异步操作失败。</li>
</ol>
<p>Promise 具有以下特点：</p>
<ol>
<li>Promise 对象是不可变的，一旦创建，其状态就不能再被改变。</li>
<li>Promise 状态只能从 pending 变为 fulfilled 或 rejected，不能逆向改变，且只能改变一次。</li>
<li>Promise 允许我们将成功和失败的处理函数分开，增加代码的可读性。</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法取消：一旦创建了 Promise，就无法取消它。这可能导致在某些情况下，不再需要结果的异步操作仍然在执行。</li>
<li>总是异步：Promise 的回调总是异步执行，即使操作已经完成。这可能会导致一些意外的行为，特别是在执行顺序敏感的情况下。</li>
<li>调试困难：由于 Promise 的链式调用和异步特性，调试 Promise 可能比调试同步代码更具挑战性。错误堆栈可能不够清晰，难以确定问题出在哪里。</li>
</ol>
<p>Promise 基本用法包括：</p>
<ol>
<li>创建 Promise 对象：通过<code>new Promise(executor)</code>创建一个 Promise 对象，其中 executor 是一个执行器函数，接受两个参数：resolve 和 reject。成功时调用 resolve 函数并传递结果，失败时调用 reject 函数并传递原因。</li>
<li>链式调用：通过<code>.then()</code>方法处理 fulfilled 状态，接受一个回调函数作为参数，当 Promise 状态变为 fulfilled 时调用。<code>.catch()</code>方法处理 rejected 状态，接受一个回调函数作为参数，当 Promise 状态变为 rejected 时调用。</li>
<li>Promise.all：接受一个 Promise 数组作为参数，当所有 Promise 都变为 fulfilled 状态时返回一个新的 Promise，其值为所有 Promise 结果的数组。如果有任意一个 Promise 变为 rejected 状态，则返回的 Promise 也变为 rejected，且返回原因是第一个 rejected 的 Promise 的原因。</li>
<li>Promise.race：接受一个 Promise 数组作为参数，返回一个新的 Promise，其状态和结果与第一个完成（无论是 fulfilled 还是 rejected）的 Promise 相同。</li>
</ol>
<p>通过使用 Promise，我们可以更有效地处理异步操作，降低代码复杂性，提高可维护性。在现代 JavaScript 开发中，Promise 已成为处理异步操作的重要基石。</p>
<h3 id="为什么-0-1-0-2-不等于-0-3"><a href="#为什么-0-1-0-2-不等于-0-3" class="headerlink" title="为什么 0.1+0.2 不等于 0.3"></a>为什么 0.1+0.2 不等于 0.3</h3><p>在 JavaScript（以及许多其他编程语言）中，0.1 + 0.2 不等于 0.3 的原因是浮点数精度问题。JavaScript 使用 IEEE 754 标准中规定的双精度浮点数（double-precision floating point）来表示数字。这种表示方法在大多数情况下都很有效，但有时会导致精度损失。</p>
<p>双精度浮点数只有有限的位数（64 位）来表示数字，其中 1 位表示符号位，11 位表示指数，以及 52 位表示尾数。当尝试表示某些数字（特别是十进制小数）时，它们的二进制表示可能是无限循环的，因此需要截断以适应有限的位数。这可能导致浮点数的近似值与实际值之间存在微小差异。</p>
<p>在本例中，0.1 和 0.2 的二进制表示都是无限循环的，需要截断。当它们被截断并以双精度浮点数存储时，这两个数字的实际值与理论值略有不同。因此，当执行 0.1 + 0.2 时，结果也会有微小误差，与 0.3 的理论值不完全相等。</p>
<p>为了解决这个问题，可以将结果四舍五入到所需的精度。例如，如果要比较两个数字是否相等，可以将它们四舍五入到一个合理的精度，然后再进行比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">areNumbersAlmostEqual</span>(<span class="params">num1, num2, epsilon = <span class="number">1e-10</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(num1 - num2) &lt; epsilon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">areNumbersAlmostEqual</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用一个称为”epsilon”的小数值来表示可接受的误差范围。我们计算两个数字之差的绝对值，如果它小于 epsilon，我们认为这两个数字几乎相等。在实践中，需要根据具体问题选择合适的 epsilon 值。</p>

      <div>
  
    <div>
  
    <div style="text-align:center;color: #A4A4A4;font-size:16px;">---------- 结束咯~~ 撒花ฅ&gt;ω&lt;*ฅ花撒 ----------</div>
  
</div>

  
</div>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/weixin.jpg" alt="壮壮姐姐~ 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/zhifubao.jpg" alt="壮壮姐姐~ 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%AB%98%E9%A2%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 高频前端面试题</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/9/" rel="prev" title="vue3">
                  <i class="fa fa-chevron-left"></i> vue3
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/12/" rel="next" title="前端面试题-HTML/CSS">
                  前端面试题-HTML/CSS <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>

<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("05/01/2021 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
    }
setInterval("createtime()",250);
</script>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">壮壮姐姐~</span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
